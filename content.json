[{"title":"http方法","date":"2017-04-26T02:43:56.000Z","path":"2017/04/26/http方法/","text":"什么是 HTTP ？超文本传输协议（HTTP）的设计目的是保证客户端与服务器之间的通信。&nbsp;HTTP&nbsp;的工作方式是客户端与服务器之间的请求-应答协议。web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 &nbsp;GET&nbsp; - 从指定的资源请求数据。 &nbsp;POST&nbsp; - 向指定的资源提交要被处理的数据。 GET 方法请注意，查询字符串（名称/值对）是在&nbsp;GET&nbsp;请求的 URL 中发送的：1/test/demo_form.php?name1=value1&amp;name2=value2 有关&nbsp;GET&nbsp;请求的其他一些注释： &nbsp;GET&nbsp;请求可被缓存 &nbsp;GET&nbsp;请求保留在浏览器历史记录中 &nbsp;GET&nbsp;请求可被收藏为书签 &nbsp;GET&nbsp;请求不应在处理敏感数据时使用 &nbsp;GET&nbsp;请求有长度限制 &nbsp;GET&nbsp;请求只应当用于取回数据 POST 方法请注意，查询字符串（名称/值对）是在&nbsp;POST&nbsp;请求的&nbsp;HTTP&nbsp;消息主体中发送的：123POST /test/demo_form.php HTTP/1.1Host: w3cschool.ccname1=value1&amp;name2=value2 有关 POST 请求的其他一些注释： &nbsp;POST&nbsp; 请求不会被缓存 &nbsp;POST&nbsp; 请求不会保留在浏览器历史记录中 &nbsp;POST&nbsp; 不能被收藏为书签 &nbsp;POST&nbsp; 请求对数据长度没有要求 其他 HTTP 请求方法下面的表格列出了其他一些 HTTP 请求方法： 方法描述500请求未完成。服务器遇到不可预知的情况。HEAD与 GET 相同，但只返回 HTTP 报头，不返回文档主体。PUT上传指定的 URI 表示。DELETE删除指定资源。OPTIONS返回服务器支持的 HTTP 方法。CONNECT把请求连接转换到透明的 TCP/IP 通道。","tags":[{"name":"http","slug":"http","permalink":"https://gj201314.github.io/tags/http/"},{"name":"http方法","slug":"http方法","permalink":"https://gj201314.github.io/tags/http方法/"}]},{"title":"http消息","date":"2017-04-26T02:43:47.000Z","path":"2017/04/26/http消息/","text":"1xx: 信息消息描述100服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。103用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。 2xx: 成功消息描述200请求成功（这是对HTTP请求成功的标准应答。）201请求被创建完成，同时新的资源被创建。202供处理的请求已被接受，但是处理未完成。203请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。204请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。205请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。206客户发送了一个带有Range头的GET请求，服务器完成了它。 3xx: 重定向消息描述300多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。301所请求的页面已经转移至新的 URL 。302所请求的页面已经临时转移至新的 URL 。303所请求的页面可在别的 URL 下被找到。304未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305客户请求的文档应该通过Location头所指明的代理服务器提取。306目前已不再使用，但是代码依然被保留。307被请求的页面已经临时移至新的 URL 。308用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。 4xx: 客户端错误消息描述400因为语法错误，服务器未能理解请求。401合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。402此代码尚无法使用。403合法请求，但对被请求页面的访问被禁止。404服务器无法找到被请求的页面。405请求中指定的方法不被允许。406服务器生成的响应无法被客户端所接受。407用户必须首先使用代理服务器进行验证，这样请求才会被处理。408请求超出了服务器的等待时间。409由于冲突，请求无法被完成。410被请求的页面不可用。411“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。412请求中的前提条件被服务器评估为失败。413由于所请求的实体太大，服务器不会接受请求。414由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。415由于媒介类型不被支持，服务器不会接受请求。416客户端请求部分文档，但是服务器不能提供被请求的部分。417服务器不能满足客户在请求中指定的请求头。 5xx: 服务器错误消息描述500请求未完成。服务器遇到不可预知的情况。501请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。502请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。503服务器当前不可用（过载或者当机）。504网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。505服务器不支持请求中指明的HTTP协议版本。511用户需要提供身份验证来获取网络访问入口。 来源地址：http://www.runoob.com/tags/html-httpmethods.html","tags":[{"name":"http","slug":"http","permalink":"https://gj201314.github.io/tags/http/"},{"name":"http状态码","slug":"http状态码","permalink":"https://gj201314.github.io/tags/http状态码/"}]},{"title":"html5WebSocket","date":"2017-04-26T02:43:05.000Z","path":"2017/04/26/html5WebSocket/","text":"WebSocket&nbsp;是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立&nbsp;WebSocket&nbsp;连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取&nbsp;Web Socket&nbsp;连接后，你可以通过&nbsp;send()&nbsp;方法来向服务器发送数据，并通过 &nbsp;onmessage&nbsp;事件来接收服务器返回的数据。 以下 API 用于创建 WebSocket 对象。1var Socket = new WebSocket(url, [protocol] ); 以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。 WebSocket 属性以下是&nbsp;WebSocket&nbsp;对象的属性。假定我们使用了以上代码创建了 Socket 对象：&nbsp;Socket.readyState&nbsp;和&nbsp;Socket.bufferedAmount&nbsp;属性只读属性&nbsp;readyState&nbsp;表示连接状态，可以是以下值： 0 - 表示连接尚未建立。 1 - 表示连接已建立，可以进行通信。 2 - 表示连接正在进行关闭。 3 - 表示连接已经关闭或者连接不能打开。 WebSocket 事件以下是&nbsp;WebSocket&nbsp;对象的相关事件。假定我们使用了以上代码创建了&nbsp;Socket&nbsp;对象： 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 WebSocket 方法以下是&nbsp;WebSocket&nbsp;对象的相关方法。假定我们使用了以上代码创建了&nbsp;Socket&nbsp;对象： 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 WebSocket 实例&nbsp;WebSocket&nbsp;协议本质上是一个基于 TCP 的协议。为了建立一个&nbsp;WebSocket&nbsp;连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的&nbsp;WebSocket&nbsp;连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 客户端的 HTML 和 JavaScript目前大部分浏览器支持&nbsp;WebSocket()&nbsp;接口，你可以在以下浏览器中尝试实例： Chrome, Mozilla, Opera 和 Safari。runoob_websocket.html 文件内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function WebSocketTest() &#123; if (\"WebSocket\" in window) &#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"sse\"&gt; &lt;a href=\"javascript:WebSocketTest()\"&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 安装 pywebsocket在执行以上程序前，我们需要创建一个支持&nbsp;WebSocket&nbsp;的服务。从pywebsocket下载 mod_pywebsocket ,或者使用 git 命令下载：1git clone https://github.com/google/pywebsocket.git mod_pywebsocket 需要 python 环境支持mod_pywebsocket 是一个 Apache HTTP 的 Web Socket扩展，安装步骤如下： 解压下载的文件。 进入 pywebsocket 目录。 执行命令： 12$ python setup.py build$ sudo python setup.py install 查看文档说明: 1$ pydoc mod_pywebsocket 开启服务在 pywebsocket/mod_pywebsocket 目录下执行以下命令：1$ sudo python standalone.py -p 9998 -w ../example/ 以上命令会开启一个端口号为 9998 的服务，使用 -w 来设置处理程序 echo_wsh.py 所在的目录。现在我们可以在 Chrome 浏览器打开前面创建的 runoob_websocket.html 文件。如果你的浏览器支持&nbsp;WebSocket()&nbsp;, 点击”运行 WebSocket”，你就可以看到整个流程各个步骤弹出的窗口，流程 Gif 演示： 来源地址：http://www.runoob.com/html/html5-websocket.html","tags":[{"name":"html5","slug":"html5","permalink":"https://gj201314.github.io/tags/html5/"},{"name":"web Socket","slug":"web-Socket","permalink":"https://gj201314.github.io/tags/web-Socket/"}]},{"title":"html5 SSE","date":"2017-04-26T02:42:38.000Z","path":"2017/04/26/html5Sse/","text":"Server-Sent 事件 - 单向消息传递Server-Sent 事件指的是网页自动获取来自服务器的更新。以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。 浏览器支持所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。 接收 Server-Sent 事件通知EventSource&nbsp;对象用于接收服务器发送事件通知：12345var source=new EventSource(\"demo_sse.php\");source.onmessage=function(event)&#123; document.getElementById(\"result\").innerHTML+=event.data + \"&lt;br&gt;\";&#125;; 尝试一下 实例解析： 创建一个新的&nbsp;EventSource&nbsp;对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”） 每接收到一次更新，就会发生&nbsp;onmessage&nbsp;事件 当&nbsp;onmessage&nbsp;事件发生时，把已接收的数据推入 id 为 “result” 的元素中 检测 Server-Sent 事件支持以下实例，我们编写了一段额外的代码来检测服务器发送事件的浏览器支持情况：1234567if(typeof(EventSource)!==\"undefined\")&#123; // 浏览器支持 Server-Sent // 一些代码.....&#125;else&#123;// 浏览器不支持 Server-Sent..&#125; 服务器端代码实例为了让上面的例子可以运行，您还需要能够发送数据更新的服务器（比如 PHP 和 ASP）。服务器端事件流的语法是非常简单的。把 “Content-Type” 报头设置为 “text/event-stream”。现在，您可以开始发送事件流了。12345678&lt;?phpheader('Content-Type: text/event-stream');header('Cache-Control: no-cache');$time = date('r');echo \"data: The server time is: &#123;$time&#125;\\n\\n\";flush();?&gt; ASP 代码 (VB) (demo_sse.asp):123456&lt;%Response.ContentType=&quot;text/event-stream&quot;Response.Expires=-1Response.Write(&quot;data: &quot; &amp; now())Response.Flush()%&gt; 代码解释: 把报头 “Content-Type” 设置为 “text/event-stream” 规定不对页面进行缓存 输出发送日期（始终以 “data: “ 开头） 向网页刷新输出数据 EventSource 对象上面的例子中，我们使用&nbsp;onmessage&nbsp;事件来获取消息。不过还可以使用其他事件： 事件 描述 onopen 当通往服务器的连接被打开 onmessage 当接收到消息 onerror 当发生错误 来源地址：http://www.runoob.com/html/html5-serversentevents.html","tags":[{"name":"html5","slug":"html5","permalink":"https://gj201314.github.io/tags/html5/"},{"name":"Server-Sent Events","slug":"Server-Sent-Events","permalink":"https://gj201314.github.io/tags/Server-Sent-Events/"}]},{"title":"html5web SQL","date":"2017-04-26T01:57:36.000Z","path":"2017/04/26/html5webSql/","text":"如果你是一个 Web 后端程序员，应该很容易理解 SQL 的操作。你也可以参考 SQL 教程，了解更多数据库操作知识。Web SQL&nbsp; 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。 核心方法以下是规范中定义的三个核心方法：1.openDatabase&nbsp;：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。2.transaction&nbsp;：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。3.executeSql&nbsp;：这个方法用于执行实际的 SQL 查询。 打开数据库我们可以使用&nbsp;openDatabase()&nbsp;方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库，使用代码如下：1var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); openDatabase() &nbsp;方法对应的五个参数说明：1.数据库名称2.版本号3.描述文本4.数据库大小5.创建回调第五个参数，创建回调会在创建数据库后被调用。 执行查询操作执行操作使用database.transaction()函数：1234var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');&#125;); 上面的语句执行后会在 ‘mydb’ 数据库中创建一个名为 LOGS 的表。 插入数据在执行上面的创建表语句后，我们可以插入一些数据：123456var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');&#125;); 我们也可以使用动态值来插入数据：12345var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id,log) VALUES (?, ?), [e_id, e_log]');&#125;); 实例中的 e_id 和 e_log 是外部变量，executeSql&nbsp;会映射数组参数中的每个条目给 “?”。 读取数据以下实例演示了如何读取数据库中已经存在的数据：1234567891011121314151617181920var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');&#125;);db.transaction(function (tx) &#123; tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) &#123; var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++)&#123; alert(results.rows.item(i).log ); &#125; &#125;, null);&#125;); 完整实例12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); var msg; db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg; &#125;); db.transaction(function (tx) &#123; tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) &#123; var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++)&#123; msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; &#125; &#125;, null); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"status\" name=\"status\"&gt;状态信息&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 尝试一下 删除记录删除记录使用的格式如下：123db.transaction(function (tx) &#123; tx.executeSql('DELETE FROM LOGS WHERE id=1');&#125;); 删除指定的数据id也可以是动态的：123db.transaction(function(tx) &#123; tx.executeSql('DELETE FROM LOGS WHERE id=?', [id]);&#125;); 更新记录更新记录使用的格式如下：123db.transaction(function (tx) &#123; tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2');&#125;); 更新指定的数据id也可以是动态的：123db.transaction(function(tx) &#123; tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=?', [id]);&#125;); 完整实例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); var msg; db.transaction(function (tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg; &#125;); db.transaction(function (tx) &#123; tx.executeSql('DELETE FROM LOGS WHERE id=1'); msg = '&lt;p&gt;删除 id 为 1 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg; &#125;); db.transaction(function (tx) &#123; tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2'); msg = '&lt;p&gt;更新 id 为 2 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg; &#125;); db.transaction(function (tx) &#123; tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) &#123; var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++)&#123; msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; &#125; &#125;, null); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"status\" name=\"status\"&gt;状态信息&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 尝试一下 来源地址：http://www.runoob.com/html/html5-web-sql.html","tags":[{"name":"html5","slug":"html5","permalink":"https://gj201314.github.io/tags/html5/"},{"name":"Web SQL","slug":"Web-SQL","permalink":"https://gj201314.github.io/tags/Web-SQL/"}]},{"title":"html5web储存","date":"2017-04-26T01:56:37.000Z","path":"2017/04/26/html5web储存/","text":"html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage&nbsp;的概念和&nbsp;cookie&nbsp;相似，区别是它是为了更大容量存储设计的。&nbsp;Cookie&nbsp;的大小是受限的，并且每次你请求一个新的页面的时候&nbsp;Cookie&nbsp;都会被发送过去，这样无形中浪费了带宽，另外&nbsp;cookie&nbsp;还需要指定作用域，不可以跨域调用。除此之外，&nbsp;Web Storage&nbsp;拥有&nbsp;setItem&nbsp;,&nbsp;getItem&nbsp;,&nbsp;removeItem&nbsp;,&nbsp;clear&nbsp;等方法，不像&nbsp;cookie&nbsp;需要前端开发者自己封装setCookie，getCookie。但是&nbsp;Cookie&nbsp;也是不可以或缺的：&nbsp;Cookie&nbsp;的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而&nbsp;Web Storage&nbsp;仅仅是为了在本地“存储”数据而生（来自@otakustay 的纠正） html5 web storage的浏览器支持情况浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的&nbsp;UserData&nbsp;其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持&nbsp;web storage&nbsp;。要判断浏览器是否支持&nbsp;localStorage&nbsp;可以使用下面的代码：123456if(window.localStorage)&#123; alert(\"浏览支持localStorage\")&#125;else&#123; alert(\"浏览暂不支持localStorage\")&#125;//或者 if(typeof window.localStorage == 'undefined')&#123; alert(\"浏览暂不支持localStorage\") &#125; localStorage和sessionStorage操作localStorage&nbsp;和&nbsp;sessionStorage&nbsp;都具有相同的操作方法，例如&nbsp;setItem&nbsp;、&nbsp;getItem&nbsp;和&nbsp;removeItem&nbsp;等&nbsp;localStorage&nbsp;和&nbsp;sessionStorage&nbsp;的方法：&nbsp;setItem&nbsp;存储value用途：将value存储到key字段用法：.setItem( key, value)代码示例：12sessionStorage.setItem(\"key\", \"value\");localStorage.setItem(\"site\", \"js8.in\"); &nbsp;getItem&nbsp;获取value用途：获取指定key本地存储的值用法：.getItem(key)代码示例：12var value = sessionStorage.getItem(\"key\");var site = localStorage.getItem(\"site\"); &nbsp;removeItem&nbsp;删除key用途：删除指定key本地存储的值用法：.removeItem(key)代码示例：12sessionStorage.removeItem(\"key\");localStorage.removeItem(\"site\"); &nbsp;clear&nbsp;清除所有的key/value用途：清除所有的key/value用法：.clear()代码示例：12sessionStorage.clear();localStorage.clear(); 其他操作方法：点操作和[]&nbsp;web Storage&nbsp;不但可以用自身的&nbsp;setItem&nbsp;,&nbsp;getItem&nbsp;等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储，像如下的代码：1234var storage = window.localStorage; storage.key1 = \"hello\";storage[\"key2\"] = \"world\";console.log(storage.key1);console.log(storage[\"key2\"]); localStorage和sessionStorage的key和length属性实现遍历&nbsp;sessionStorage&nbsp;和&nbsp;localStorage&nbsp;提供的key()和length可以方便的实现存储的数据遍历，例如下面的代码：1234567var storage = window.localStorage;for (var i=0, len = storage.length; i &lt; len; i++)&#123;var key = storage.key(i);var value = storage.getItem(key);console.log(key + \"=\" + value);&#125; storage事件&nbsp;storage&nbsp;还提供了&nbsp;storage&nbsp;事件，当键值改变或者&nbsp;clear&nbsp;的时候，就可以触发&nbsp;storage&nbsp;事件，如下面的代码就添加了一个&nbsp;storage&nbsp;事件改变的监听：12345678910if(window.addEventListener)&#123;window.addEventListener(\"storage\",handle_storage,false);&#125;else if(window.attachEvent)&#123;window.attachEvent(\"onstorage\",handle_storage);&#125;function handle_storage(e)&#123;if(!e)&#123;e=window.event;&#125;&#125; 来源地址：http://www.jb51.net/html5/144597.html","tags":[{"name":"html5","slug":"html5","permalink":"https://gj201314.github.io/tags/html5/"},{"name":"Web Storage","slug":"Web-Storage","permalink":"https://gj201314.github.io/tags/Web-Storage/"}]},{"title":"this用法实例","date":"2017-04-24T03:13:10.000Z","path":"2017/04/24/this用法实例/","text":"本文实例讲述了JS函数this的用法。分享给大家供大家参考。具体如下：在js中写函数时，很多用到this. this究竟是什么,this是个关键字，是个指针，指向执行环境作用域，也称之为上下文。 先说下函数吧，个人理解是函数是在语言中重复调用的代码块.在JS里，把函数赋值给对象的属性时，称之为方法,如：123456var m=&#123;&#125;;m.title='title';m.show=function()&#123; alert(this.title)&#125;m.show() 就是把函数作为对象m的方法来调用这样的话，this指向的就是m这个对象.直接调函数名的叫函数：12345var a=1212;function show()&#123; alert(a)//1212&#125;show()// 1212 在全局环境里，可以把全局变量理解为&nbsp;window&nbsp;的属性，全局函数为&nbsp;window&nbsp;的方法看下面的例子：1234567891011121314var m =&#123;&#125;;m.id='mmm';m.show=function()&#123; alert(this.id);&#125;var a=&#123;&#125;;a.id='aaa';a.show=m.show;a.show(); //aaaa.show=m.show; 先理解这句话，因为函数是个对象，m.show=function()&#123; alert(this.id)&#125; 这表达式相当于a.show 与m.show同时引用指向123function()&#123; alert(this.id)&#125; 其实相当于123a.show=function()&#123; alert(this.id)&#125; 所以调用a.show()时，this指向的是a对象,再看以下一个栗子1234567891011var m =&#123;&#125;;m.id='mmm'm.show=function()&#123; alert(this.id)&#125;var a=&#123;&#125;a.id='aaa'a.show=function()&#123; m.show()&#125;;a.show(); //mmm 所以调用a.show()时，相当于调用了m.show()的方法,所以this.指向的是m对象。再看以下一个例子，一开始还是不很懂12345678910111213var color='red';var app = &#123;&#125;;app.color=\"green\";app.paint=function(node)&#123;node.style.color=this.color; alert(this.color);&#125;function findNode(callback)&#123; var btn =document.querySelector('.btn'); callback(btn);//传进来，&#125;findNode(app.paint);alert(this.color); //red 而不是green 函数传参时，是按值传参的，而不是引用所以findNode(app.paint);传进来时，其实是1234function(node)&#123; node.style.color=this.color; alert(this.color);&#125; 的引用,又因为findNode是全局定义的，所以this指向&nbsp;WINDOW OR UNDEFINED&nbsp;;关于传参，按值传递过去的123function show(a)&#123; alert(a)&#125; 参数为基本数据类型时好理解12var b=10;show(b)//alert(10); 至于对象123456var c =&#123;&#125;;c.prop=true;var showProp=function(obj)&#123; obj.prop=false&#125;showProp(c); //c.prop = false 有些人觉得是上面例子是按引用传参其实上面还是按值传参,showProp(c)&nbsp;把c传进函数里时，c其实相当于一个引用, 函数里对&nbsp;obj.prop=false&nbsp;,相当于对引用的对象 改成&nbsp;{prop:false}&nbsp; 再看下面一例子123456789var c =&#123;&#125;;c.prop=true;var showProp=function(obj)&#123; obj = new Object(); obj.prop=false return obj;&#125;showProp(c);alert(c.prop); //true 里明明把传入obj修改了，如果按照函数按引用传参，函数里面的修改肯定会反映到外部来源地址：http://www.jb51.net/article/60804.htm","tags":[{"name":"js","slug":"js","permalink":"https://gj201314.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"https://gj201314.github.io/tags/this/"},{"name":"this用法","slug":"this用法","permalink":"https://gj201314.github.io/tags/this用法/"}]},{"title":"this详解","date":"2017-04-24T03:12:40.000Z","path":"2017/04/24/this详解/","text":"this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，123function test()&#123; this.x = 1;&#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。 纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象&nbsp;Global。 请看下面这段代码，它的运行结果是1。12345function test()&#123; this.x = 1; alert(this.x);&#125;test(); // 1 为了证明this就是全局对象，我对代码做一些改变：12345var x = 1;function test()&#123; alert(this.x);&#125;test(); // 1 运行结果还是1。再变一下：123456var x = 1;function test()&#123; this.x = 0;&#125;test();alert(x); //0 作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 apply调用apply()&nbsp;是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为1o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o来源地址：http://www.jb51.net/article/41656.htm","tags":[{"name":"js","slug":"js","permalink":"https://gj201314.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"https://gj201314.github.io/tags/this/"},{"name":"this指向","slug":"this指向","permalink":"https://gj201314.github.io/tags/this指向/"}]},{"title":"gulp工具安装和使用","date":"2017-04-20T08:40:31.000Z","path":"2017/04/20/gulp工具安装和使用/","text":"gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快。如果你还没有使用过前端构建工具，或者觉得gruntjs太难用的话，那就尝试一下gulp吧。 本文内容：1.gulp的安装2.开始使用gulp3.gulp的API介绍4.一些常用的gulp插件 gulp的安装首先确保你已经正确安装了nodejs环境。然后以全局方式安装gulp：1npm install -g gulp 全局安装gulp后，还需要在每个要使用gulp的项目中都单独安装一次。把目录切换到你的项目文件夹中，然后在命令行中执行：1npm install gulp 如果想在安装的时候把gulp写进项目package.json文件的依赖中，则可以加上–save-dev：1npm install --save-dev gulp 这样就完成了gulp的安装。至于为什么在全局安装gulp后，还需要在项目中本地安装一次，有兴趣的可以看下stackoverflow上有人做出的回答：why-do-we-need-to-install-gulp-globally-and-locally、what-is-the-point-of-double-install-in-gulp。大体就是为了版本的灵活性，但如果没理解那也不必太去纠结这个问题，只需要知道通常我们是要这样做就行了。 开始使用gulp建立gulpfile.js文件就像gruntjs需要一个&nbsp;Gruntfile.js&nbsp;文件一样，gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做&nbsp;gulpfile.js&nbsp;。新建一个文件名为&nbsp;gulpfile.js&nbsp;的文件，然后放到你的项目目录中。之后要做的事情就是在&nbsp;gulpfile.js&nbsp;文件中定义我们的任务了。下面是一个最简单的&nbsp;gulpfile.js&nbsp;文件内容示例，它定义了一个默认的任务。1234var gulp = require('gulp');gulp.task('default',function()&#123; console.log('hello world');&#125;); ├── gulpfile.js├── node_modules│ └── gulp└── package.json 运行gulp任务要运行gulp任务，只需切换到存放&nbsp;gulpfile.js&nbsp;文件的目录(windows平台请使用cmd或者Power Shell等工具)，然后在命令行中执行gulp命令就行了，gulp后面可以加上要执行的任务名，例如&nbsp;gulp task1&nbsp;，如果没有指定任务名，则会执行任务名为&nbsp;default&nbsp;的默认任务。 gulp的API介绍使用gulp，仅需知道4个API即可：&nbsp;gulp.task()&nbsp;,&nbsp;gulp.src()&nbsp;,&nbsp;gulp.dest()&nbsp;,&nbsp;gulp.watch()&nbsp;，所以很容易就能掌握，但有几个地方需理解透彻才行，我会在下面一一说明。为了避免出现理解偏差，建议先看一遍官方文档。 gulp.src()在介绍这个API之前我们首先来说一下Grunt.js和Gulp.js工作方式的一个区别。Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。而在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的&nbsp;pipe()&nbsp;方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因。再回到正题上来，&nbsp;gulp.src()&nbsp;方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：1gulp.src(globs[, options]) globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。options为可选参数。通常情况下我们不需要用到。 下面我们重点说说Gulp用到的glob的匹配规则以及一些文件匹配技巧。Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件： 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。? 匹配文件路径中的一个字符(不会匹配路径分隔符)[…] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)下面以一系列例子来加深理解 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js. 能匹配 a.js,style.css,a.b,x.y//.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件/.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.jsa//z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/za/b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录?.js 能匹配 a.js,b.js,c.jsa?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符[xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符[^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js当有多种匹配模式时可以使用数组12//使用数组的方式来匹配多种文件gulp.src(['js/*.js','css/*.css','*.html'])使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上&nbsp;!&nbsp;即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式12gulp.src([*.js,'!b*.js']) //匹配所有js文件，但排除掉以b开头的js文件gulp.src(['!b*.js',*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式相加起来得到的结果。展开的例子如下：a{b,c}d 会展开为 abd,acda{b,}c 会展开为 abc,aca{0..3}d 会展开为 a0d,a1d,a2d,a3da{b,c{d,e}f}g 会展开为 abg,acdfg,acefga{b,c}d{e,f}g 会展开为 abdeg,acdeg,abdeg,abdfg gulp.dest()gulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path为写入文件的路径options为一个可选的参数对象，通常我们不需要用到 要想使用好&nbsp;gulp.dest()&nbsp;这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。gulp的使用流程一般是这样子的：首先通过&nbsp;gulp.src()&nbsp;方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到&nbsp;gulp.dest()&nbsp;中，&nbsp;gulp.dest()&nbsp;方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给&nbsp;gulp.dest()&nbsp;传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如：1234var gulp = require('gulp');gulp.src('script/jquery.js') .pipe(gulp.dest('dist/foo.js'));//最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js 要想改变文件名，可以使用插件&nbsp;gulp-rename&nbsp; 下面说说生成的文件路径与我们给&nbsp;gulp.dest()&nbsp;方法传入的路径参数之间的关系。&nbsp;gulp.dest(path)&nbsp;生成的文件路径是我们传入的path参数后面再加上&nbsp;gulp.src()&nbsp;中有通配符开始出现的那部分路径。例如：12345var gulp = reruire('gulp');//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js') .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js 再举更多一点的例子1234567891011ulp.src('script/avalon/avalon.js') //没有通配符出现的情况 .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/avalon.js//有通配符开始出现的那部分路径为 **/underscore.jsgulp.src('script/**/underscore.js') //假设匹配到的文件为script/util/underscore.js .pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/util/underscore.jsgulp.src('script/*') //有通配符出现的那部分路径为 * //假设匹配到的文件为script/zepto.js .pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/zepto.js 通过指定&nbsp;gulp.src()&nbsp;方法配置参数中的base属性，我们可以更灵活的来改变&nbsp;gulp.dest()&nbsp;生成的文件路径。当我们没有在&nbsp;gulp.src()&nbsp;方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：1gulp.src('app/src/**/*.css') //此时base的值为 app/src 上面我们说的&nbsp;gulp.dest()&nbsp;所生成的文件路径的规则，其实也可以理解成，用我们给&nbsp;gulp.dest()&nbsp;传入的路径替换掉&nbsp;gulp.src()&nbsp;中的base路径，最终得到生成文件的路径。123gulp.src('app/src/**/*.css') //此时base的值为app/src,也就是说它的base路径为app/src //设该模式匹配到了文件 app/src/css/normal.css .pipe(gulp.dest('dist')) //用dist替换掉base路径，最终得到 dist/css/normal.css 所以改变base路径后，&nbsp;gulp.dest()&nbsp;生成的文件路径也会改变1234567gulp.src(script/lib/*.js) //没有配置base参数，此时默认的base路径为script/lib //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest('build')) //生成的文件路径为 build/jquery.jsgulp.src(script/lib/*.js, &#123;base:'script'&#125;) //配置了base参数，此时base路径为script //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest('build')) //此时生成的文件路径为 build/lib/jquery.js 用&nbsp;gulp.dest()&nbsp;把文件流写入文件后，文件流仍然可以继续使用。 gulp.task()&nbsp;gulp.task&nbsp;方法用来定义任务，内部使用的是Orchestrator，其语法为：1gulp.task(name[, deps], fn); name 为任务名deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。123gulp.task('mytask', ['array', 'of', 'task', 'names'], function() &#123; //定义一个有依赖的任务 // Do something&#125;); &nbsp;gulp.task()&nbsp;这个API没什么好讲的，但需要知道执行多个任务时怎么来控制任务执行的顺序。gulp中执行多个任务，可以通过任务依赖来实现。例如我想要执行&nbsp;one&nbsp;,&nbsp;two&nbsp;,&nbsp;three&nbsp;这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task('default',['one','two','three']); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：1234567891011gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;);//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？有三种方法可以实现：第一：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。1234567891011gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done'); 第二：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 第三：返回一个promise对象，例如12345678910111213var Q = require('q'); //一个著名的异步处理的库 https://github.com/kriskowal/qgulp.task('one',function(cb)&#123; var deferred = Q.defer(); // 做一些异步操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 5000); return deferred.promise;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); gulp.task()&nbsp;就这些了，主要是要知道当依赖是异步任务时的处理。 gulp.watch()gulp.watch()&nbsp;用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为1gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与&nbsp;gulp.src()&nbsp;方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到tasks 为文件变化后要执行的任务，为一个数组1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()&nbsp;还有另外一种使用方式：1gulp.watch(glob[, opts, cb]) glob&nbsp;和opts&nbsp;参数与第一种用法相同cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type&nbsp;属性为变化的类型，可以是&nbsp;added&nbsp;,&nbsp;changed&nbsp;,&nbsp;deleted&nbsp;；&nbsp;path&nbsp;属性为发生变化的文件的路径1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); 一些常用的gulp插件gulp的插件数量虽然没有grunt那么多，但也可以说是应有尽有了，下面列举一些常用的插件。 自动加载插件使用gulp-load-plugins安装：1npm install --save-dev gulp-load-plugins 要使用gulp的插件，首先得用&nbsp;require&nbsp;来把插件加载进来，如果我们要使用的插件非常多，那我们的&nbsp;gulpfile.js&nbsp;文件开头可能就会是这个样子的：1234567891011var gulp = require('gulp'), //一些gulp插件,abcd这些命名只是用来举个例子 a = require('gulp-a'), b = require('gulp-b'), c = require('gulp-c'), d = require('gulp-d'), e = require('gulp-e'), f = require('gulp-f'), g = require('gulp-g'), //更多的插件... z = require('gulp-z'); 虽然这没什么问题，但会使我们的&nbsp;gulpfile.js&nbsp;文件变得很冗长，看上去不那么舒服。&nbsp;gulp-load-plugins&nbsp;插件正是用来解决这个问题。gulp-load-plugins&nbsp;这个插件能自动帮你加载&nbsp;package.json&nbsp;文件里的gulp插件。例如假设你的&nbsp;package.json&nbsp;文件里的依赖是这样的:12345678&#123; \"devDependencies\": &#123; \"gulp\": \"~3.6.0\", \"gulp-rename\": \"~1.2.0\", \"gulp-ruby-sass\": \"~0.4.3\", \"gulp-load-plugins\": \"~0.5.1\" &#125;&#125; 然后我们可以在&nbsp;gulpfile.js&nbsp;中使用gulp-load-plugins来帮我们加载插件：123var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')(); 然后我们要使用gulp-rename和gulp-ruby-sass这两个插件的时候，就可以使用&nbsp;plugins.rename&nbsp;和&nbsp;plugins.rubySass&nbsp;来代替了,也就是原始插件名去掉&nbsp;gulp-&nbsp;前缀，之后再转换为驼峰命名。实质上&nbsp;gulp-load-plugins&nbsp;是为我们做了如下的转换12plugins.rename = require('gulp-rename');plugins.rubySass = require('gulp-ruby-sass'); gulp-load-plugins&nbsp;并不会一开始就加载所有&nbsp;package.json&nbsp;里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件。最后要提醒的一点是，因为&nbsp;gulp-load-plugins&nbsp;是通过你的&nbsp;package.json&nbsp;文件来加载插件的，所以必须要保证你需要自动加载的插件已经写入到了&nbsp;package.json&nbsp;文件里，并且这些插件都是已经安装好了的。 重命名使用gulp-rename安装：1npm install --save-dev gulp-rename 用来重命名文件流中的文件。用&nbsp;gulp.dest()&nbsp;方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用&nbsp;gulp-rename&nbsp;插件来改变文件流中的文件名。1234567891011var gulp = require('gulp'), rename = require('gulp-rename'), uglify = require(\"gulp-uglify\");gulp.task('rename', function () &#123; gulp.src('js/jquery.js') .pipe(uglify()) //压缩 .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest('js')); //关于gulp-rename的更多强大的用法请参考https://www.npmjs.com/package/gulp-rename&#125;); js文件压缩使用gulp-uglify安装：1npm install --save-dev gulp-uglify 用来压缩js文件，使用的是uglify引擎12345678var gulp = require('gulp'), uglify = require(\"gulp-uglify\");gulp.task('minify-js', function () &#123; gulp.src('js/*.js') // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest('dist/js')); //压缩后的路径&#125;); css文件压缩使用gulp-minify-css安装：1npm install --save-dev gulp-minify-css 要压缩css文件时可以使用该插件12345678var gulp = require('gulp'), minifyCss = require(\"gulp-minify-css\");gulp.task('minify-css', function () &#123; gulp.src('css/*.css') // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest('dist/css'));&#125;); html文件压缩使用gulp-minify-html安装：1npm install --save-dev gulp-minify-html 用来压缩html文件12345678var gulp = require('gulp'), minifyHtml = require(\"gulp-minify-html\");gulp.task('minify-html', function () &#123; gulp.src('html/*.html') // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest('dist/html'));&#125;); js代码检查使用gulp-jshint安装：1npm install --save-dev gulp-jshint 用来检查js代码12345678var gulp = require('gulp'), jshint = require(\"gulp-jshint\");gulp.task('jsLint', function () &#123; gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并使用gulp-concat安装：1npm install --save-dev gulp-concat 用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了12345678var gulp = require('gulp'), concat = require(\"gulp-concat\");gulp.task('concat', function () &#123; gulp.src('js/*.js') //要合并的文件 .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 \"all.js\" .pipe(gulp.dest('dist/js'));&#125;); less和sass的编译less使用gulp-less,安装：1npm install --save-dev gulp-less 12345678var gulp = require('gulp'), less = require(\"gulp-less\");gulp.task('compile-less', function () &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('dist/css'));&#125;); sass使用gulp-sass,安装：1npm install --save-dev gulp-sass 12345678var gulp = require('gulp'), sass = require(\"gulp-sass\");gulp.task('compile-sass', function () &#123; gulp.src('sass/*.sass') .pipe(sass()) .pipe(gulp.dest('dist/css'));&#125;); 图片压缩可以使用gulp-imagemin插件来压缩jpg、png、gif等图片。安装：1npm install --save-dev gulp-imagemin 123456789101112var gulp = require('gulp');var imagemin = require('gulp-imagemin');var pngquant = require('imagemin-pngquant'); //png图片压缩插件gulp.task('default', function () &#123; return gulp.src('src/images/*') .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest('dist'));&#125;); gulp-imagemin的使用比较复杂一点，而且它本身也有很多插件，建议去它的项目主页看看文档 自动刷新使用gulp-livereload插件，安装:1npm install --save-dev gulp-livereload 当代码变化时，它可以帮我们自动刷新页面该插件最好配合谷歌浏览器来使用，且要安装livereload chrome extension扩展插件,不能下载的请自行FQ。 123456789101112131415var gulp = require('gulp'), less = require('gulp-less'), livereload = require('gulp-livereload');gulp.task('less', function() &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('css')) .pipe(livereload());&#125;);gulp.task('watch', function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch('less/*.less', ['less']);&#125;); 来源地址：http://www.cnblogs.com/2050/p/4198792.html","tags":[{"name":"gulp","slug":"gulp","permalink":"https://gj201314.github.io/tags/gulp/"},{"name":"前端工具","slug":"前端工具","permalink":"https://gj201314.github.io/tags/前端工具/"}]},{"title":"hexo搭建个人博客","date":"2017-04-18T10:06:06.000Z","path":"2017/04/18/hexo搭建个人博客/","text":"本文主要讲在windows下，如何使用hexo搭建个人博客，以及hexo的常用命令 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了gitbash工具； nodejs版本在6.10.2； 本文环境： Windows10.0 nodejs@6.10.2 搭建github博客创建仓库新建一个名为&nbsp;你的用户名.github.io&nbsp;的仓库，比如说，如果你的github用户名是test，那么你就新建&nbsp;test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：&nbsp;username.github.io，其中&nbsp;username&nbsp;是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到&nbsp;.ssh\\id_rsa.pub&nbsp;文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示&nbsp;Are you sure you want to continue connecting (yes/no)?&nbsp;输入yes，然后会看到： 1Hi liuxianan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种&nbsp;_config.yml&nbsp;文件，一个是根目录下的全局的&nbsp;_config.yml&nbsp;，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是&nbsp;F:\\Workspaces\\hexo&nbsp;，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s&nbsp;是开启本地预览服务，打开浏览器访问 http://localhost:4000即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子： 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改&nbsp;_config.yml&nbsp;中的&nbsp;theme: landscape&nbsp;改为&nbsp;theme: yilia，然后重新执行&nbsp;hexo g&nbsp;来重新生成。 如果出现一些莫名其妙的问题，可以先执行&nbsp;hexo clean&nbsp;来清理一下&nbsp;public&nbsp;的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，&nbsp;ssh key&nsbp;肯定要配置好。 其次，配置&nbsp;_config.yml&nsbp;中有关deploy的部分： 正确写法：1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 错误写法：1234deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行&nbsp;hexo d&nbsp;的话一般会报如下错误：1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件：1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用&nbsp;git bash，否则会提示&nbsp;Permission denied (publickey)&nbsp;. 打开你的&nbsp;git bash&nbsp;，输入&nbsp;hexo d&nbsp;就会将本次有改动的代码全部提交，没有改动的不会： 保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令：12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令：1hexo new 'my-first-blog' hexo会帮我们在&nbsp;_posts&nbsp;下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么&nbsp;hexo new page ‘postName’&nbsp;命令和&nbsp;hexo new ‘postName’&nbsp;有什么区别呢？ 1hexo new page \"my-second-blog\" 生成如下： 最终部署时生成：&nbsp;hexo\\public\\my-second-blog\\index.html&nbsp;，但是它不会作为文章出现在博文目录。 写博客工具那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上&nbsp;&nbsp;即可，例如：12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果： 来源地址：http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#前言","tags":[{"name":"hexo","slug":"hexo","permalink":"https://gj201314.github.io/tags/hexo/"},{"name":"搭建hexo个人博客","slug":"搭建hexo个人博客","permalink":"https://gj201314.github.io/tags/搭建hexo个人博客/"}]},{"title":"npm使用介绍","date":"2017-04-13T08:33:06.000Z","path":"2017/04/13/npm使用介绍/","text":"NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 查看npm版本号：1$ npm -v npm升级：1npm install npm -g 使用 npm 命令安装模块：1$ npm install &lt;Module Name&gt; *注意：$代表当前目录 本地安装包会放在当前目录下的node_modules中，在代码中只需要通过 require(‘Module Name’) 的方式就好，无需指定第三方包路径 全局安装与本地安装npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如： 12npm install express -g # 全局安装npm install express # 本地安装 本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。 使用 npm 查看安装信息：你可以使用以下命令来查看所有全局安装的模块1$ npm list -g 如果要查看某个模块的版本号，可以使用命令如下1$ npm list grunt ###使用 package.jsonpackage.json 位于模块的目录下，用于定义包的属性。 属性说明： name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。 keywords - 关键字 使用 npm 卸载模块：1$ npm uninstall express 使用 npm 更新模块：1$ npm update express 使用 npm 搜索模块：1$ npm search express 使用 npm 创建模块：1$ npm init 在npm资源库中注册用户：1$ npm adduser 使用 npm 发布模块：1$ npm publish npm常用命令：1.NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。2.使用npm help 可查看某条命令的详细帮助，例如npm help install。3.在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。4.使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。5.使用npm update -g可以把全局安装的对应命令行程序更新至最新版。6.使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。7.使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 使用 npm 镜像：1$ npm install -g cnpm --registry=https://registry.npm.taobao.org","tags":[{"name":"npm","slug":"npm","permalink":"https://gj201314.github.io/tags/npm/"},{"name":"npm使用","slug":"npm使用","permalink":"https://gj201314.github.io/tags/npm使用/"}]}]